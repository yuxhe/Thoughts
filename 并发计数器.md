
计数器操作   await 阻塞  

barrier.await()  内部有计数器;阻塞在栅栏处 **同时临界点调用对象的回调方法**  CountDownLatch是不能复用的



public class CyclicBarrierDemo {
	    //指定必须有6个运动员到达才行
	    private static CyclicBarrier barrier = new CyclicBarrier(6, () -> {
	        System.out.println("所有运动员入场，裁判员一声令下！！！！！");
	    });
	    public static void main(String[] args) {
	        System.out.println("运动员准备进场，全场欢呼............");
	
	        ExecutorService service = Executors.newFixedThreadPool(6);
	        for (int i = 0; i < 6; i++) {
	            service.execute(() -> {
	                try {
	                    System.out.println(Thread.currentThread().getName() + " 运动员，进场");
	                    barrier.await();
	                    System.out.println(Thread.currentThread().getName() + "  运动员出发");
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                } catch (BrokenBarrierException e) {
	                    e.printStackTrace();
	                }
	            });
	        }
	    }
	
	}



**Semaphore用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑Semaphore。**

**等待队列中移入到同步队列中去**

由于BlockingQueue内部实现就附加了两个阻塞操作。即当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满；当队列为空时，阻塞从队列中获取数据的线程，直至队列非空时为止。

void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；

**sleep不会让出时间片，yield会让出时间片**

condition机制比synchronized更灵活、支持多队列，另一个支持一个，前者支持中断、支持park、unpark级别调整线程状态 waiting状态，以及移入同步队列有机会获取到lock

-----------------------------------------------
Factorybean 也会放入容器中，只是他的目的是产生某些bean而已 比如第三方的bean ;是个接口 要实现三个方法getobject返回对象 , getobjectType返回类类型,是否单列isSingle ；Object factoryBean=container.getBean("&nextDayDate")返回对象,再强制转换可使用了

Aware接口 ，bean的实例处理方式、反射或cglib或动态生成子类；可动态扩展属性，比如实例前、实例后等可回调的方法；拿到了实例的定义及再封装些属性

@Autowired 需依赖注入容器中的对象
@Qualifier 多个实例时如何找；

@Resource 考名字注入

//对象的生命周期、不依赖注入的，只是管理对象的生命周期，标注与方法名上面
@PostConstruct 被容器实例化时会被调用；@PreDestroy

-------------------------------------------------------------
】利用延迟关联或者子查询优化超多分页场景。
说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回
N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过
特定阈值的页数进行 SQL 改写。
正例：先快速定位需要获取的 id 段，然后再关联：
 SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id


【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts
最好。
说明：
1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。
反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级
别比较 range 还低，与全表扫描是小巫见大巫。

【推荐】建组合索引的时候，区分度最高的在最左边。
正例：如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a
索引即可。
说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c>? and
d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c

------

【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行

【参考】如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数
的区别。
说明：
 SELECT LENGTH("轻松工作")； 返回为 12
 SELECT CHARACTER_LENGTH("轻松工作")； 返回为 4
 如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别

sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入

【推荐】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字
段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL
时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储

【推荐】高并发服务器建议调小 TCP 协议的 **time_wait 超时时间**。
说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服
务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上
调小此等待值。
正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：
net.ipv4.tcp_fin_timeout = 30

----------------
建议将 linux
**服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）**

-----------------------------------------
 【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场
景时输出 dump 信息。
说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常
有帮助。

【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆
大小带来的压力

【参考】**服务器内部重定向使用 forward**；外部重定向地址使用 URL 拼装工具类来生成，否则
会带来 URL 维护不一致的问题和潜在的安全风险。

8. 【推荐】**类在设计与实现时要符合单一原则**。
说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计
的初衷

说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但
核心关键点上的必要设计和文档沉淀是需要的

--------------
**单机环境下**的函数调 用常常可以在**微秒级内**返回，所以除了少数访问外 部设备（例如磁盘、网卡等）的函数采用异步方式 调用外，大部分函数采用同步调用的方式

**计算机之间**的函数调用（远 程调用，即RPC）的返回时间通常是**毫秒**或亚毫秒 （0.1～1.0毫秒）级，差不多是单机环境**的100 倍**

分布式系 统涉及**数据分布、复制、一致性、容错、可扩展性 等**分布式技术

**性能预估**

分布式存储系统的挑战主要在于数据、状态信 息的持久化，要求在自动迁移、自动容错、并发读 写的过程中保证数据的一致性。分布式存储涉及的 技术主要来自两个领域：分布式系统以及数据库， 如下所示： ●数据分布：如何将数据分布到多台服务器才能 够保证数据分布均匀？数据分布到多台服务器后如
何实现跨服务器读写操作？ ●一致性：如何将数据的多个副本复制到多台服 务器，即使在异常情况下，也能够保证不同副本之 间的数据一致性？

●容错：如何检测到服务器故障？如何自动将出 现故障的服务器上的数据和服务迁移到集群中其他 服务器？ ●负载均衡：新增服务器和集群正常运行过程中 如何实现自动负载均衡？数据迁移的过程中如何保 证不影响已有服务？

●事务与并发控制：如何实现分布式事务？如何 实现多版本并发控制？

●易用性：如何设计对外接口使得系统容易使
用？如何设计监控系统并将系统的内部状态以方便 的形式暴露给运维人员？

●压缩/解压缩：如何根据数据的特点设计合理 的压缩/解压缩算法？如何平衡压缩算法节省的存 储空间和消耗的CPU计算资源？

分布式存储系统挑战大，研发周期长，涉及的 知识面广。一般来讲，工程师如果能够深入理解分 布式存储系统，理解其他互联网后台架构不会再有 任何困难。

分布式存储面临的数据需求比较复杂，大致可 以分为三类： ●非结构化数据：包括所有格式的办公文档、文 本、图片、图像、音频和视频信息等。 ●结构化数据：一般存储在关系数据库中，可以 用二维关系表结构来表示。结构化数据的模式（Schema，包括属性、数据类型以及数据之间的 联系）和内容是分开的，数据的模式需要预先定 义
●半结构化数据：介于非结构化数据和结构化数 据之间，HTML文档就属于半结构化数据。它一般 是自描述的，与结构化数据最大的区别在于，半结
构化数据的模式结构和内容混在一起，没有明显的 区分，也不需要预先定义数据的模式结构。
不同的分布式存储系统适合处理不同类型的数 据，本书将分布式存储系统分为四类：分布式文件 系统、分布式键值（Key-Value）系统、分布式表 格系统和分布式数据库。
1.分布式文件系统 互联网应用需要存储大量的图片、照片、视频 等非结构化数据对象，这类数据以对象的形式组 织，对象之间没有关联，这样的数据一般称为 Blob（Binary Large Object，二进制大对象）数 据分布式文件系统用于存储Blob对象，典型的系
统有Facebook Haystack以及Taobao File System（TFS）。另外，分布式文件系统也常作为 分布式表格系统以及分布式数据库的底层存储，如 谷歌的GFS（Google File System，存储大文件）可以作为分布式表格系统Google Bigtable的底层 存储，Amazon的EBS（Elastic Block Store，弹性 块存储）系统可以作为分布式数据库（Amazon RDS）的底层存储。 总体上看，分布式文件系统存储三种类型的数 据：Blob对象、定长块以及大文件。在系统实现层 面，分布式文件系统内部按照数据块（chunk）来 组织数据，每个数据块的大小大致相同，每个数据 块可以包含多个Blob对象或者定长块，一个大文件
也可以拆分为多个数据块，如图1-1所示。分布式 文件系统将这些数据块分散到存储集群，处理数据 复制、一致性、负载均衡、容错等分布式系统难 题，并将用户对Blob对象、定长块以及大文件的操 作映射为对底层数据块的操作。
2.分布式键值系统 分布式键值系统用于存储关系简单的半结构化
数据，它只提供基于主键的 CRUD（Create/Read/Update/Delete）功能，即 根据主键创建、读取、更新或者删除一条键值记 录。
典型的系统有Amazon Dynamo以及Taobao Tair。从数据结构的角度看，分布式键值系统与传 统的哈希表比较类似，不同的是，分布式键值系统 支持将数据分布到集群中的多个存储节点。分布式 键值系统是分布式表格系统的一种简化实现，一般 用作缓存，比如淘宝Tair以及Memcache。一致性 哈希是分布式键值系统中常用的数据分布技术，因 其被Amazon DynamoDB系统使用而变得相当有 名。
3.分布式表格系统 分布式表格系统用于存储关系较为复杂的半结 构化数据，与分布式键值系统相比，分布式表格系 统不仅仅支持简单的CRUD操作，而且支持扫描某 个主键范围。分布式表格系统以表格为单位组织数 据，每个表格包括很多行，通过主键标识一行，支 持根据主键的CRUD功能以及范围查找功能。
分布式表格系统借鉴了很多关系数据库的技 术，例如支持某种程度上的事务，比如单行事务， 某个实体组（Entity Group，一个用户下的所有数 据往往构成一个实体组）下的多行事务。典型的系 统包括Google Bigtable以及Megastore,Microsoft Azure Table Storage,Amazon DynamoDB等。与
分布式数据库相比，分布式表格系统主要支持针对 单张表格的操作，不支持一些特别复杂的操作，比 如多表关联，多表联接，嵌套子查询；另外，在分 布式表格系统中，同一个表格的多个数据行也不要 求包含相同类型的列，适合半结构化数据。分布式 表格系统是一种很好的权衡，这类系统可以做到超 大规模，而且支持较多的功能，但实现往往比较复 杂，而且有一定的使用门槛。
4.分布式数据库 分布式数据库一般是从单机关系数据库扩展而 来，用于存储结构化数据。分布式数据库采用二维 表格组织数据，提供SQL关系查询语言，支持多表 关联，嵌套子查询等复杂操作，并提供数据库事务

-------------------------------
面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类

单一职责原则，就是指就一个类而言，应该仅有一个引起它变化的原因；开放—封闭原则是说对扩展开发，对修改关闭，通俗的讲，就是我们在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展；依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象；

迪米特法则（LoD）也叫最少知识原则，简单的说，就是如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。迪米特法则还是在讲如何减少耦合的问题，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。 第三者的接入 相连性


门面模式要求一个子系统的外部与其内部的通信必须通过一个统一的门面(Facade)对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。现在用了门面模式以后，耦合比以前要少很多了，更改会更加方便，扩展也很容易了


若是程序不会变化，原有的设计就没什么问题，运行结果正确足够了，但若是程序可能会时常随业务而变化，新的设计就大大提高了应变性，这其实就是应用设计模式的目的所在。

**设计模式就是 对业务的一种抽象，程序抗业务变化能力**；

------------------------
**分布式**在解决网站**高并发**问题

数据在分
布式的环境中保持**数据一致性**也非常困难，**分布式事务**也难以保证

**动静分离,反向代理**,CDN

,NoSQL 产品几乎都是分布式,
分布式环境下实现并发和协同的**分布式锁**,

支持云存储的**分布式文件系统**等,

**集群**，目的就是提高系统的可用性,

**缓存**;**本地缓存**：在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无需访问数据库,**分布式缓存**,使用缓存有两个前提条件，一是数据访问**热点不均衡**，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会**很快过期**，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。 **间隔时间，防止某时间点均失效**

**消息队列实现异步**


-----------------------------------------

表 4.1 常用系统操作响应时间表操 作 响应时间 

打开一个网站 几秒

在数据库中查询一条记录（有索引） 十几毫秒

机械磁盘一次寻址定位 4 毫秒

从机械磁盘顺序读取 1MB 数据 2 毫秒

从 SSD 磁盘顺序读取 1MB 数据 0.3 毫秒

从远程分布式缓存 Redis 读取一个数据 0.5 毫秒

从内存中读取 1MB 数据 十几微秒

Java 程序本地方法调用 几微秒

网络传输 2KB 数据 1 微秒

----
**测试一万次执行需要的总响应时间之和，然后除以一万，得到单次请求的响应时间**

网站系统用户数>>网站在线用户数>>网站并发用户数

**多线程然后不停地发送请求**，而是在两次请求之间加入一个随机等待时间，这个时间被称作思考时间

吞吐量 请求数  qps每秒  tps每秒   吞吐量指一定时间内；并发数指此时正在的

性能计数器 指监控各个指标情况cpu\内存、硬盘、网卡等

系统负载指的cpu ,top命令 查看最近1分钟、10分钟、15分钟平均进程数 可看出进程、cpu的使用情况，cpu有富裕及系统资源不足的情况

负载测试、压力测试、稳定测试、性能测试

性能分析 分析系统的瓶颈在哪儿，定位瓶颈，内存、磁盘、网卡、cpu、程序等


Web 前端性能优化
一般说来 Web 前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、
CDN 服务等，主要优化手段有优化浏览器访问、使用反向代理、CDN 等

1）减少HTTP 的主要手段是合并 CSS、合并 JavaScript、合并图片；

2）使用浏览器缓存

3）启用压缩

4）4．CSS 放在页面最上面、JavaScript 放在页面最下面  不一定哈

5）减少 Cookie 传输

CDN 加速 本质也是缓存思路，离用户最近的路径上拉取静态内容，有cdn服务商的参与、有dns方面的内容知识；A记录去掉，增加cname的配置、解析出域名ip地址、动态的；

反向代理、负载均衡技术

------------------------------------
事件驱动的：epoll是nio的某种实现、非阻塞的，发起IO读或写非阻塞的;而读、写的过程是阻塞的，通常一个线程监听连接；
AIO为异步IO方式；windows上实现此种方式；

esb基于总线的数据交换，支持路由、支持多协议，制定标准的通讯协议、兼顾多方；

**jvm解析出来的常量 直接通过入栈方式放到栈顶**

堆默认最大内存可为物理内存的四分之一；TLAB是基于线程分配的、无锁、分配快些，新对象最好在TLAB上

jstat 分析堆上使用情况   GT?

-------------------------

表 4-1：状态码的类别 类别 原因短语 
1XX Informational（信息性状态码） 接收的请求正在处理 
2XX Success（成功状态码） 请求正常处理完毕 
3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 
4XX Client Error（客户端错误状态码） 服务器无法处理请求 
5XX Server Error（服务器错误状态码） 服务器处理请求出错


303 状态码明确 表示客户端应当采用 GET 方法获取资源
很多现存的浏览器将 302 响应视为 303 响应，并且使用 GET方式访问在 Location 中规定的 URI，而无视原先请求的方法。所以作者说这里使用 303 是最 理想的

当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次 发送。 
301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使 用时大家都会这么做;

304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系

附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部

尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响 应时的行为，每种浏览器有可能出现不同的情况。


400 Bad Request 该状态码表示请求报文中存在语法错误

401 Unauthorized  认证方面的

403 Forbidden 未授权的发 送源 IP 地址试图访问

404 Not Found 该状态码表明服务器上无法找到请求的资源

500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误

502 服务器网关方面的错误

503 Service Unavailable 现在无法 处理请求 ，服务积压

缓存代理

透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 （Transparent Proxy）。反之，对报文内容进行加工的代理被称为非 透明代理

**隧道**可按要求建立起一条与其他服务器的通信线路，届时使用 **SSL**等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行**安全的通信**。 **隧道本身不会去解析HTTP请求**。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。

通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在；隧道是正向代理技术；

客户端的缓存 最明显的浏览器行为；

------

HTTP/1.1 规范定义了如下 47 种首部字段。 
表 6-1：通用首部字段 
首部字段名 说明 
Cache-Control 控制缓存的行为      此处是否可利用呢？
Connection 逐跳首部、连接的管理 
Date 创建报文的日期时间 
Pragma 报文指令 
Trailer 报文末端的首部一览 
Transfer-Encoding 指定报文主体的传输编码方式 
Upgrade 升级为其他协议   在websocket中看到了
Via 代理服务器的相关信息 
Warning 错误通知


请求首部字段
首部字段名
说明 
Accept 用户代理可处理的媒体类型  此处看上去没啥用，主要是服务器不理会
Accept-Charset 优先的字符集 
Accept-Encoding 优先的内容编码 
Accept-Language 优先的语言（自然语言） 
Authorization Web认证信息 E          此处有用
xpect 期待服务器的特定行为 
From 用户的电子邮箱地址 
Host 请求资源所在服务器 
If-Match 比较实体标记（ETag）   以下这些304等有用哈
If-Modified-Since 比较资源的更新时间 
If-None-Match 比较实体标记（与 If-Match 相反） 
If-Range 资源未更新时发送实体 Byte 的范围请求 
If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） 
Max-Forwards 最大传输逐跳数 
Proxy-Authorization 代理服务器要求客户端的认证信息 
Range 实体的字节范围请求 
Referer 对请求中  此处有用
URI 的原始获取方  
TE 传输编码的优先级 
User-Agent HTTP 客户端程序的信息 此处有用


表 6-3：响应首部字段 首部字段名 说明 
Accept-Ranges 是否接受字节范围请求 
Age 推算资源创建经过时间 
ETag 资源的匹配信息    304可利用
Location 令客户端重定向至指定URI             302等可利用重定向的地址
Proxy-Authenticate 代理服务器对客户端的认证信息 
Retry-After 对再次发起请求的时机要求 
Server HTTP服务器的安装信息 
Vary 代理服务器缓存的管理信息 
WWW-Authenticate 服务器对客户端的认证信息

表 6-4：实体首部字段 首部字段名 说明 
Allow 资源可支持的HTTP方法 
Content-Encoding 实体主体适用的编码方式 
Content-Language 实体主体的自然语言 
Content-Length 实体主体的大小（单位：字节） 
Content-Location 替代对应资源的URI 
Content-MD5 实体主体的报文摘要 
Content-Range 实体主体的位置范围 
Content-Type 实体主体的媒体类型    可利用
Expires 实体主体过期的日期时间     可利用
Last-Modified 资源的最后修改日期时间  可利用


非 HTTP/1.1 首部字段 在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定 义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高

6.2.6 End-to-end 首部和 Hop-by-hop 首部 HTTP 首部字段将定义**成缓存代理和非缓存代理的行为**，分成 2 种类 型。端到端首部（End-to-end Header） 分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必 须保存在由缓存生成的响应中，另外规定它必须被转发。 逐跳首部（Hop-by-hop Header） 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再 转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提 供 Connection 首部字段

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于**端到端首部**。 
Connection 
Keep-Alive 
Proxy-Authenticate 
Proxy-Authorization 
Trailer 
TETransfer-Encoding 
Upgrade

------------------------------
Cache-Control: no-cache 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。 如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。 Cache-Control: no-cache=Location 由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数； 嗯，**Cache-Control: no-cache 可以被好好利用**下；但事实上 no-cache 代表不缓 存过期的资源

Cache-Control: no-store  no-store 才是真正地不进行缓存，请 读者注意区别理解

当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器

当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间

应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略

Cache-Control: no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。 这样做可防止缓存或代理压缩图片等类似操作。 **规定了代理的一些行为**

Connection 首部字段具备如下两个作用。 
1）控制不再转发给代理的首部字段       控制代理服务器行为只发GET / Http/1.1
   GET / Http/1.1
   Upgrade:    http1.1 
   Connection  Upgrade

   **Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间**。

2）管理持久连接  Connection: close

Connection: 不再转发的首部字段名

管理持久连接  Connection: close 
HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close

---------------------------------------------------------------
Connection: Keep-Alive HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。 如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应

Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。 规范定义的形式唯一，如下所示。 Pragma: no-cache 该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户 端会要求所有的中间服务器不返回缓存的资源

Cache-Control: no-cache 
Pragma: no-cache
所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache- Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段

首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时

以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 （分块长度 0 之后）出现了首部字段 Expires

Transfer-Encoding
首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式
Transfer-Encoding: chunked


------------
Via 使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。 报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。 首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容   **可利用请求追踪呀**


表 6-7：HTTP/1.1 警告码 警告码 警告内容 说明 
110 Response is stale（响应已过期） 代理返回已过期的资源 
111 Revalidation failed（再验证失败） 代理再验证资源有效性时失败（服务 器无法到达等原因） 
112 Disconnection operation（断开连接操 作） 代理与互联网连接被故意切断 
113 Heuristic expiration（试探性过期） 响应的使用期超过24小时（有效缓存 的设定时间大于24小时的情况下） 
199 Miscellaneous warning（杂项警告） 任意的警告内容 
214 Transformation applied（使用了转换） 代理对内容编码或媒体类型等执行了 某些处理时 
299 Miscellaneous persistent warning（持久 杂项警告） 任意的警告内容


虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分  可以明白ngix可配置多个server 就是这个host区分开来的

If-Match: "123456" 首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参 照本章有关首部字段 ETag 的说明）

如果在 If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求，否则304

只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理 该请求。与 If-Match 首部字段的作用相反

Range: bytes=5001-10000 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。

**Location**: http://www.usagidesign.jp/sample.html 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。

Server: Apache/2.2.6 (Unix) PHP/5.2.5  服务端返回的首部信息

它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。

Allow: GET, HEAD 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回


Content-Encoding: gzip 首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选 用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行 的压缩。

首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。

Base64 编码 解决了二进制的问题

Content-Range: bytes 5001-10000/10000 对应客户端

Content-Type: text/html; charset=UTF-8  首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 **type/subtype** 形式赋值

Expires: Wed, 04 Jul 2012 08:26:05 GMT 首部字段 Expires 会将资源失效的日期告知客户端。

**源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值**

但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令

Last-Modified: Wed, 23 May 2012 09:59:55 GMT 首部字段 Last-Modified 指明资源最终修改的时间

**网景通信公司设计并开发了 Cookie**

首部字段名 说明 首部类型 
Set-Cookie 开始状态管理所使用的Cookie信息 
响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段

Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp; 当服务器准备开始管理客户端的状态时，会事先告知各种信息。 下面的表格列举了 Set-Cookie 的字段值

表 6-9：Set-Cookie 字段的属性 129
属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问

domain 属性 通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比 如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie

Set-Cookie: name=value; HttpOnly 通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。 但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后 的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了

通信的加密 一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 **SSL**（Secure Socket Layer，安全套接层）或 **TLS**（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。

用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 **SSL组合使用的 HTTP 被称为 HTTPS**（HTTP Secure，超文本传输安全协议）或 HTTP over SSL

SSL不仅提供**加密**处理，而且还使用了一种被称为**证书**的手段， 可用于确定方。

证书由值得信任的第三方机构颁发，用以证明服务器和客户端是 实际存在的

https 存在服务端证书确认过程，目的确认服务器是就是我要访问的目的地；客户端确认服务端的一步过程；

**MD5 和 SHA-1等散列值，散列值算法；**  MD5 是由单向函 数生成的散列值

**HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS**

HTTPS 是身披 SSL 外壳的 HTTP HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代 替而已

公开密钥加密使用一对非对称的密钥，

由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书

首先，服务器 的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证 机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签 名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书 后绑定在一起。

服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称 为证书。

接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书 上的数字签名进行验证，一旦验证通过，客户端便可明确两件事： 一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二， 服务器的公开密钥是值得信赖的。

此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布 版本时，会事先在内部植入常用认证机关的公开密钥。  **客户端持有公钥证书，客户端公钥加密  --- 服务端私钥解密**

客户端那份证书 如何植入浏览器的呀 ？  防止钓鱼网站 ？

银行的网上银行就采用了客户端证书。在登录网银时不仅 要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以 确认用户是否从特定的终端访问网银。 客户端的合法性 。

GET /chat HTTP/1.1 Host: server.example.com 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== 
Origin: http://example.com 
Sec-WebSocket-Protocol: chat, superchat 
Sec-WebSocket-Version: 13 

Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。 Sec-WebSocket-Protocol 字段内记录使用的子协议

握手·响应 对于之前的请求，
返回状态码 
101 Switching Protocols 的响应。 
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 
Sec-WebSocket-Protocol: chat 

Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec- WebSocket-Key 的字段值生成的。 成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数 据帧，而采用 WebSocket 独立的数据帧。

成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数 据帧，而采用 WebSocket 独立的数据帧

图：HTTPS 通信 
步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包 含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所 使用的加密算法及密钥长度等）。 

步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。 

步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。

步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL握手协商部分结束。 

步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。 

步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 

步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。 

步骤 8： 服务器同样发送 Change Cipher Spec 报文。 

步骤 9： 服务器同样发送 Finished 报文。

步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。 

步骤 11： 应用层协议通信，即发送 HTTP 响应。 

步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。 在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。




























































